--CREATE DATABASE eurofleet_logistics;

--Implementing btre_gist for exclusion constraints with date ranges
CREATE EXTENSION IF NOT EXISTS btree_gist;

--DROP INDEXES
DROP INDEX IF EXISTS idx_address_type_id; 
DROP INDEX IF EXISTS idx_vehicle_id; 
DROP INDEX IF EXISTS idx_staff_id;
DROP INDEX IF EXISTS idx_origin_address_id;
DROP INDEX IF EXISTS idx_dest_address_id;

--DROP TABLES reverse order
DROP TABLE IF EXISTS shipment;
DROP TABLE IF EXISTS assignment;
DROP TABLE IF EXISTS assignment_status;
DROP TABLE IF EXISTS supplier_contract;
DROP TABLE IF EXISTS supplier;
DROP TABLE IF EXISTS staff_certification;
DROP TABLE IF EXISTS certification_type;
DROP TABLE IF EXISTS app_user;
DROP TABLE IF EXISTS staff;
DROP TABLE IF EXISTS staff_role;
DROP TABLE IF EXISTS clearance_level;
DROP TABLE IF EXISTS vehicle_registration;
DROP TABLE IF EXISTS vehicle;
DROP TABLE IF EXISTS vehicle_model;
DROP TABLE IF EXISTS vehicle_type;
DROP TABLE IF EXISTS dealership;
DROP TABLE IF EXISTS garage;
DROP TABLE IF EXISTS contact_info;
DROP TABLE IF EXISTS address;
DROP TABLE IF EXISTS postcode;
DROP TABLE IF EXISTS region;
DROP TABLE IF EXISTS address_type;
DROP TABLE IF EXISTS powertrain;

--CREATE TABLES

-- Crucial for type of vehicle power.
CREATE TABLE powertrain(
	powertrain_id SERIAL PRIMARY KEY,
	powertrain_type VARCHAR(20) NOT NULL,
	powertrain_description TEXT 
);

-- Important for querying, such as in address WHERE address_type = n
CREATE TABLE address_type(
	address_type_id SERIAL PRIMARY KEY,
	address_type_name VARCHAR(50) NOT NULL UNIQUE
);

--Natural key for regions.
CREATE TABLE region(
	region_code VARCHAR(10) PRIMARY KEY,
	region_name VARCHAR(50) NOT NULL UNIQUE
);

-- If multiple addresses are in a postcode, utilise postcode lookup.
CREATE TABLE postcode(
	postcode_id SERIAL PRIMARY KEY,
	postcode VARCHAR(8) UNIQUE NOT NULL,
	town VARCHAR(100),
	region_code VARCHAR(10) NOT NULL,
	FOREIGN KEY (region_code) REFERENCES region(region_code) ON DELETE RESTRICT
);

-- Address information for various tables (garage, dealership, shipment origin/destination etc)
CREATE TABLE address(
	address_id SERIAL PRIMARY KEY,
	street VARCHAR(100) NOT NULL,
	postcode_id INT NOT NULL,
	address_type_id INT NOT NULL,
	UNIQUE (street, postcode_id, address_type_id),
	FOREIGN KEY (postcode_id) REFERENCES postcode(postcode_id)
	ON DELETE RESTRICT ON UPDATE CASCADE,
	FOREIGN KEY (address_type_id) REFERENCES address_type(address_type_id)
	ON DELETE CASCADE ON UPDATE CASCADE
);

-- Relevant Contact Information
CREATE TABLE contact_info(
	contact_id SERIAL PRIMARY KEY,
	email_address VARCHAR(80) NOT NULL UNIQUE,
	phone_number VARCHAR(13)
);

-- Handling of storing trucks, maintenance
CREATE TABLE garage(
	garage_id SERIAL PRIMARY KEY,
	garage_name VARCHAR(50),
	contact_id INT,
	address_id INT,
	FOREIGN KEY (contact_id) REFERENCES contact_info(contact_id)
	ON DELETE CASCADE,
	FOREIGN KEY (address_id) REFERENCES address(address_id)
	ON DELETE CASCADE ON UPDATE CASCADE
);

-- Dealerships for the Trucks (Location, contact info)
CREATE TABLE dealership(
	dealership_id SERIAL PRIMARY KEY,
	dealership_name VARCHAR(50) NOT NULL,
	address_id INT NOT NULL,
	contact_id INT NOT NULL,
	FOREIGN KEY (address_id) REFERENCES address(address_id)
	ON DELETE CASCADE,
	FOREIGN KEY (contact_id) REFERENCES contact_info(contact_id)
	ON DELETE CASCADE
);

-- The types of vehicle (Scania have many)
CREATE TABLE vehicle_type(
	vehicle_type_id SERIAL PRIMARY KEY,
	vehicle_type_name VARCHAR(40) NOT NULL
);


CREATE TABLE vehicle_model(
	model_id SERIAL PRIMARY KEY,
	model_name VARCHAR(40),
	powertrain_id INT NOT NULL,
	vehicle_type_id INT NOT NULL,
	FOREIGN KEY (powertrain_id) REFERENCES powertrain(powertrain_id),
	FOREIGN KEY (vehicle_type_id) REFERENCES vehicle_type(vehicle_type_id)
);

-- Vehicle itself implementing prior table info, plus as its fleet vehicles, includes when purchased, mileage trackable for legality, 
CREATE TABLE vehicle(
	vehicle_id INT GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY,
	vehicle_number VARCHAR(100) NOT NULL,
	model_id INT NOT NULL,
	manufactured_year SMALLINT CHECK (manufactured_year BETWEEN 1900 AND EXTRACT(YEAR FROM CURRENT_DATE)),
	created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	mileage INT DEFAULT 0 CHECK (mileage >= 0) NOT NULL, --Check ensures non-negative
	FOREIGN KEY (model_id) REFERENCES vehicle_model(model_id)
	ON DELETE CASCADE 
);

CREATE TABLE vehicle_registration(
	vehicle_registration_id INT GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY,
	vehicle_id INT NOT NULL,
	number_plate VARCHAR(20) NOT NULL,
	registration_period daterange NOT NULL, -- eg: [2024-01-01, 2024-01-03]
	FOREIGN KEY (vehicle_id) REFERENCES vehicle(vehicle_id)
	ON DELETE CASCADE ON UPDATE CASCADE,

	EXCLUDE USING gist (
		number_plate WITH =,
		registration_period WITH && 
	)
);

CREATE TABLE clearance_level(
	clearance_id SERIAL PRIMARY KEY,
	clearance_type VARCHAR(40) NOT NULL UNIQUE,
	clearance_description TEXT
);

CREATE TABLE staff_role(
	staff_role_id SERIAL PRIMARY KEY,
	role_name VARCHAR(40) NOT NULL UNIQUE,
	clearance_id INT NOT NULL,
	FOREIGN KEY (clearance_id) REFERENCES clearance_level(clearance_id) 
);
-- DOnt wish to cascade delete clearance levels.

CREATE TABLE staff(
	staff_id INT GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY, --Start auto_increment at 1000
	surname VARCHAR(30) NOT NULL,
	forename VARCHAR(30) NOT NULL,
	staff_role_id INT NOT NULL,	
	hire_date DATE NOT NULL,
	contact_id INT NOT NULL,
	address_id INT NOT NULL,
	FOREIGN KEY (staff_role_id) REFERENCES staff_role(staff_role_id)
	ON DELETE CASCADE,
	FOREIGN KEY (contact_id) REFERENCES contact_info(contact_id)
	ON DELETE CASCADE ON UPDATE CASCADE,
	FOREIGN KEY (address_id) REFERENCES address(address_id)
	ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE app_user(
	user_id SERIAL PRIMARY KEY,
	staff_id INT NOT NULL UNIQUE,
	username VARCHAR(40) NOT NULL UNIQUE,
	hashed_password VARCHAR(255) NOT NULL,
	is_active BOOLEAN DEFAULT TRUE,
	created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	FOREIGN KEY (staff_id) REFERENCES staff(staff_id)
	ON DELETE RESTRICT
);



CREATE TABLE certification_type(
	cert_type_id SERIAL PRIMARY KEY,
	cert_name VARCHAR(100) NOT NULL
);


CREATE TABLE staff_certification(
	staff_cert_id SERIAL PRIMARY KEY,
	staff_id INT NOT NULL,
	cert_type_id INT NOT NULL,
	expiry_date DATE NOT NULL,
	FOREIGN KEY (staff_id) REFERENCES staff(staff_id),
	FOREIGN KEY (cert_type_id) REFERENCES certification_type(cert_type_id),
	UNIQUE (staff_id, cert_type_id)
);

CREATE TABLE supplier(
	supplier_id SERIAL PRIMARY KEY,
	supplier_name VARCHAR(50) NOT NULL,
	contact_id INT NOT NULL,
	address_id INT NOT NULL, 
	FOREIGN KEY (contact_id) REFERENCES contact_info(contact_id)
	ON DELETE CASCADE ON UPDATE CASCADE,
	FOREIGN KEY (address_id) REFERENCES address(address_id)
	ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE supplier_contract(
	contract_id SERIAL PRIMARY KEY,
	supplier_id INT NOT NULL,
	contract_start_date DATE NOT NULL,
	contract_end_date DATE NOT NULL,
	contract_terms TEXT NOT NULL,
	contract_value DECIMAL(12, 2) NOT NULL, --
	contract_renewal_date DATE, --If necessary for renewing an assignment
	CHECK(contract_start_date < contract_end_date),
	FOREIGN KEY (supplier_id) REFERENCES supplier(supplier_id)
);

CREATE TABLE assignment_status(
	assignment_status_id SERIAL PRIMARY KEY,
	assignment_status_name VARCHAR(30) NOT NULL UNIQUE,
	status_description TEXT
);

-- Assigning Staff to Vehicles for an assignment (they may have same truck for a while, may one day have a different etc (malleable)


--TODO: Do I add staff_certification to assignments? ensuring applicable staff
CREATE TABLE assignment(
	assignment_id SERIAL PRIMARY KEY, 
	vehicle_id INT NOT NULL,
	staff_id INT NOT NULL, 
	contract_id INT NOT NULL,
	assignment_start_date DATE NOT NULL,
	assignment_deadline DATE NOT NULL,
	assignment_status_id INT NOT NULL,
	CHECK (assignment_start_date < assignment_deadline),
	FOREIGN KEY (vehicle_id) REFERENCES vehicle(vehicle_id)
	ON DELETE CASCADE ON UPDATE CASCADE,
	FOREIGN KEY (staff_id) REFERENCES staff(staff_id)
	ON DELETE CASCADE ON UPDATE CASCADE,
	FOREIGN KEY (contract_id) REFERENCES supplier_contract(contract_id),
	FOREIGN KEY (assignment_status_id) REFERENCES assignment_status(assignment_status_id)
	ON DELETE CASCADE
);

CREATE TABLE shipment(
	shipment_id SERIAL PRIMARY KEY,
	assignment_id INT NOT NULL,
	origin_address_id INT,
	dest_address_id INT,
	shipment_date DATE,
	delivery_date DATE,
	CHECK (shipment_date IS NULL OR delivery_date IS NULL OR shipment_date <= delivery_date),
	FOREIGN KEY (assignment_id) REFERENCES assignment(assignment_id)
	ON DELETE CASCADE ON UPDATE CASCADE,
	FOREIGN KEY (origin_address_id) REFERENCES address(address_id)
	ON DELETE CASCADE ON UPDATE CASCADE,
	FOREIGN KEY (dest_address_id) REFERENCES address(address_id)
	ON DELETE CASCADE ON UPDATE CASCADE
);

--CREATE INDEXES
--Address Filtering
CREATE INDEX idx_address_type_id ON address(address_type_id);

--Indexing Staff/Vehicles on assignments
CREATE INDEX idx_vehicle_id ON assignment(vehicle_id);
CREATE INDEX idx_staff_id ON assignment(staff_id);

--Shipment Query
CREATE INDEX idx_origin_address_id ON shipment(origin_address_id);
CREATE INDEX idx_dest_address_id ON shipment(dest_address_id);


--Timestamp Update Trigger Function
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
	NEW.updated_at = NOW();
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER set_timestamp
BEFORE UPDATE ON vehicle
FOR EACH ROW
	EXECUTE FUNCTION update_modified_column();


